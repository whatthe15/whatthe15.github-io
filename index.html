<!DOCTYPE html>
<html>


<head>
    <title>veeriah MG </title>
    
</head>
<body>
    
    <canvas id="canvas" width="1400" height="600"></canvas>
    <script src="gg.js"></script>
    <link rel="stylesheet" href="style.css">
    <div class="container">
    <h1>
        lab1 
        change color of the image 

    </h1>
    <h2>
        import cv2<br> 
        import matplotlib.pyplot as plt<br> 
        import numpy as np<br> 
        img = cv2.imread("C:\\Users\\schai\\Downloads\\wp2096161-pikachu-and-raichu-wallpapers.jpg")<br> 
        image = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)<br> 
        plt.imshow(image)<br> 
        plt.show()<br> 
    </h2>
    <h1>
        resize image

    </h1>
    <h2>
        import cv2<br> 
        import matplotlib.pyplot as plt<br> 
        import numpy as np<br> 
        img = cv2.imread("C:\\Users\\schai\\Downloads\\wp2096161-pikachu-and-raichu-wallpapers.jpg")<br> 
        image = cv2.resize(image, (100, 100))<br> 
        plt.imshow(image)<br> 
        plt.show()<br>
    </h2>
    <h1>
        grey scale image

    </h1>
    <h2>
        greyscale_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)<br>
        plt.imshow(greyscale_image,cmap='gray')<br>
        plt.show()<br>


    </h2>
    <h1>
        black and white image
    </h1>
    <h2>
        ret, bw_image = cv2.threshold(greyscale_image, 127, 255, cv2.THRESH_BINARY)<br>
        plt.imshow(bw_image,cmap='gray')<br>
        plt.show()<br>
    </h2>
    <h1>
        convert image into rgb planes
    </h1>
    <h2>
        r, g, b = cv2.split(image)<br>
        fig = plt.figure()<br>
        axis = fig.add_subplot(1, 3, 1, xticks=[], yticks=[])<br>
        axis.set_title("Red")<br>
        axis.imshow(r, cmap='gray')<br>
        axis = fig.add_subplot(1, 3, 2, xticks=[], yticks=[])<br>
        axis.set_title("Green")<br>
        axis.imshow(g, cmap='gray')<br>
        axis = fig.add_subplot(1, 3, 3, xticks=[], yticks=[])<br>
        axis.set_title("Blue")<br>
        axis.imshow(b, cmap='gray')<br>
        plt.show()<br>
    </h2>
    <h1>
        image profile
    </h1>

    <h2>
        size = np.size<br>
        height = img.shape[0]<br>
        width = img.shape[1]<br>
        channels = img.shape[2]<br>

        print('image dimensions are '.size)
        print('height = ',height)
        print('width = ',width)
        print('channels = ',channels)
        print("resolution of image is ",str(height)+'x'+str(width))
        
        number_of_white_pixels = np.sum(img == 255)
        print('number of white pixels = ',number_of_white_pixels)
        number_of_black_pixels = np.sum(img == 0)
        print('number of black pixels = ',number_of_black_pixels)


    </h2>
    <h1>
        reading the image
    </h1>
    <h2>
        import cv2<br>
        import matplotlib.pyplot as plt<br>
        import numpy as np<br>
        img = cv2.imread("C:\\Users\\schai\\Downloads\\wp2096161-pikachu-and-raichu-wallpapers.jpg")<br>
        image = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)<br>
        plt.imshow(image)<br>
        plt.show()<br>
    </h2>
    <h1>
        negative image
    </h1>
    <h2>
        negative_image = 255 - image<br>
        plt.imshow(negative_image)<br>
        plt.show()<br>
    </h2>
    <h1>
        image flip
    </h1>
    <h2>
        flipped_image = cv2.flip(image, 1)<br>
        plt.imshow(flipped_image)<br>
        plt.show()<br>
    </h2>
    <h1>
        image mirror flip
    </h1>
    <h2>
        mirror_image = cv2.flip(image, 0)<br>
        plt.imshow(mirror_image)<br>
        plt.show()<br>
    </h2>
    <h1>
        binary threshold image
    </h1>
    <h2>
        ret, thresh1 = cv2.threshold(image, 127, 255, cv2.THRESH_BINARY)<br>
        plt.imshow(thresh1)<br>
        plt.show()<br>
    </h2>
    <h1>
        contrast stretching
        </h1>
    <h2>
        normalised_image =cv2.normalize(image, None, alpha=0, beta=1, norm_type=cv2.NORM_MINMAX, dtype=cv2.CV_32F)<br>
        for i in range(normalised_image.shape[0]):<br>
            for j in range(normalised_image.shape[1]):<br>
                normalised_image[i][j] = normalised_image[i][j] * 255<br>
        plt.title(before contrast stretching)<br>
        plt.imshow(image)<br>
        plt.show()<br>
        plt.title(after contrast stretching)<br>
        plt.imshow(normalised_image)<br>
        plt.show()<br>
    </h2>
    <h1>
        histogram of a color image
    </h1>
    <h2>
        hist_r=cv2.calcHist([image],[0],None,[256],[0,256])<br>
        hist_g=cv2.calcHist([image],[1],None,[256],[0,256])<br>
        hist_b=cv2.calcHist([image],[2],None,[256],[0,256])<br>
        plt.plot(hist_r,color='r')<br>
        plt.plot(hist_g,color='g')<br>
        plt.plot(hist_b,color='b')<br>
        plt.show()<br>

    </h2>
    <h1>
        histogram of a grayscale image
    </h1>

    <h2>
        hist=cv2.calcHist([greyscale_image],[0],None,[256],[0,256])<br>
        plt.plot(hist)<br>
        plt.show()<br>
    </h2>
    <h1>
        histogram equalization<br>

        for grey scale image<br>
    </h1>
    <h2>
        equ = cv2.equalizeHist(greyscale_image)<br>
        res = np.hstack((greyscale_image,equ)) #stacking images side-by-side<br>
        plt.imshow(res)<br>
        plt.show()<br>
    </h2>
    <h1>
        implementing adaptive histogram equalization
    </h1>
    <h2>
        adaptive_hist = cv2.equalishiist(greyscale_image)<br>
        plt.title('before adaptive histogram equalization')<br>
        plt.imshow(greyscale_image)<br>
        plt.show()<br>
        plt.title('after adaptive histogram equalization')<br>          
        plt.imshow(adaptive_hist)<br>
        plt.show()<br>
    </h2>
    <h1>
     histogram of masked image masked image
    </h1>
    <h2>
        mask = np.zeros(image.shape[:2], np.uint8)<br>
        mask[100:300, 100:400] = 255<br>
        masked_img = cv2.bitwise_and(image, image, mask=mask)<br>
        plt.imshow(masked_img)<br>
        plt.show()<br>
        histr=cv2.calcHist([masked_img],[0],None,[256],[0,256])<br>
        histg=cv2.calcHist([masked_img],[1],None,[256],[0,256])<br>
        histb=cv2.calcHist([masked_img],[2],None,[256],[0,256])<br>
        plt.title("Histogram of the masked image")<br>
        plt.plot(histr, c ="r")<br>
        plt.plot(histg,c = "g")<br>
        plt.plot(histb, c="b")<br>
        plt.show()<br>

        plt.title("Histogram of the original image")<br>
        plt.plot(hist_r, c="r")<br>
        plt.plot(hist_g, c="g")<br>
        plt.plot(hist_b, c="b")<br>
        plt.show()<br>


    </h2>
    <h1>
        arthematic operations on image
    </h1>
        <h2>
        img1 = cv2.imread('image1.jpg')<br>
        img2 = cv2.imread('image2.jpg')<br>
        img1 = cv2.resize(img1, (512, 512))<br>
        img2 = cv2.resize(img2, (512, 512))<br>
        </h2>
        <h1>
            additionusing numpy
        </h1>
    
        <h2>
        add = img1 + img2<br>
        plt.imshow(add)<br>
        plt.show()<br>
        </h2>
    <h1>
        additionusing cv2.add()
    </h1>

        <h2>
        add = cv2.add(img1, img2)<br>
        plt.imshow(add)<br>
        plt.show()<br>

        </h2>
    <h1>subraction using numpy</h1>
        <h2>
        sub = img1 - img2<br>
        plt.imshow(sub)<br>
        plt.show()<br>
        </h2>
    <h1>subraction using cv2.subtract()</h1>
        <h2>
        sub = cv2.subtract(img1, img2)<br>
        plt.imshow(sub)<br>
        plt.show()<br>
        </h2>
        <h1>
            multiplication using numpy

        </h1>
        <h2>    
        mul = img1 * img2<br>
        plt.imshow(mul)<br>
        plt.show()<br>
        </h2>
        <h1>
            multiplication using cv2.multiply()
            

        </h1>

        <h2>
        mul = cv2.multiply(img1, img2)<br>
        plt.imshow(mul)<br>
        plt.show()<br>
        </h2>
        <h1>
            division using numpy
        </h1>
        <h2>
        div = img1 / img2<br>
        plt.imshow(div)<br>
        plt.show()<br>
        </h2>
        <h1>
            division using cv2.divide()
        </h1>
        <h2>
        div = cv2.divide(img1, img2)<br>
        plt.imshow(div)<br>
        plt.show()<br>
        </h2>
        <h1>
            logical operations on images
        </h1>
        <h2>
        img1 = cv2.imread('image1.jpg')<br>
        img2 = cv2.imread('image2.jpg')<br>
        for i in range(1080):
            temp =[]
            for j in range(1920):
                temp.append(0)
            img2.append(np.array(temp))<br>
            
        </h2>
        <h1>
            circle draw
        </h1>
        <h2>
            img = cv2.circle(img1, (100, 100), 50, (0, 0, 255), -1)<br>
            plt.imshow(img)<br>
            plt.show()<br>
        </h2>
        <h1>
            rectangle draw
        </h1>
        <h2>
            img = cv2.rectangle(img1, (100, 100), (200, 200), (0, 0, 255), -1)<br>
            plt.imshow(img)<br>
            plt.show()<br>
        </h2>
        <h1>
            and operation

        </h1>
        <h2>
            img = cv2.bitwise_and(img1, img2)<br>
            plt.imshow(img)<br>
            plt.show()<br>
        </h2>
        <h1>
            or operation
        </h1>
        <h2>
            img = cv2.bitwise_or(img1, img2)<br>
            plt.imshow(img)<br>
            plt.show()<br>
        </h2>
        <h1>
            not operation
        </h1>
        <h2>
            img = cv2.bitwise_not(img1)<br>
            plt.imshow(img)<br>
            plt.show()<br>
        </h2>
        <h1>
            xor operation
        </h1>
        <h2>
            img = cv2.bitwise_xor(img1, img2)<br>
            plt.imshow(img)<br>
            plt.show()<br>
        </h2>
        <h1>
            rotate image
        </h1>
        <h2>
            img = cv2.rotate(img1, cv2.ROTATE_90_CLOCKWISE)<br>
            plt.imshow(img)<br>
            plt.show()<br>
        </h2>
        <h1>
            bitwise and operation
        </h1>
        <h2>
            img = cv2.bitwise_and(img1, img2)<br>
            plt.imshow(img)<br>
            plt.show()<br>
        </h2>
        <h1>
            frequency domain<br>
            forward fourier transform<br>
        </h1>
        image = cv2.imread('image1.jpg')<br>
        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)<br>
        plt.figure(figsize=(10, 10),constrainted_layout =False)<br>
        img_fft = np.fft.fft2(image)<br>
        img_fft_shift = np.fft.fftshift(img_fft)<br>
        plt.imshow(np.log(1+np.abs(img_fft_shift)), cmap='gray')<br>
        plt.show()<br>
        <h1>
            inverse fourier transform
        </h1>
        img_fft_ishift = np.fft.ifftshift(img_fft_shift)<br>
        img_back = np.fft.ifft2(img_fft_ishift)<br>
        img_back = np.abs(img_back)<br>
        plt.imshow(img_back, cmap='gray')<br>
        plt.show()<br>
        <h1>
            low pass filter
        </h1>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        kernel = np.ones((5, 5), np.float32)/25<br>
        lp = cv2.filter2D(img, -1, kernel)<br>
        plt.imshow(lp, cmap='gray')<br>
        plt.show()<br>
        <h1>
            high pass filter
        </h1>
        <h2>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        filtered_image = img - cv2.gaussianBlur(img, (5, 5), 0)<br>
        plt.imshow(filtered_image, cmap='gray')<br>
        plt.show()<br>
        </h2>
        <h1>
            median filter 
        </h1>
        <h2>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        median = cv2.medianBlur(img, 5)<br>
        plt.imshow(median, cmap='gray')<br>
        plt.show()<br>
        </h2>
        <h1>
            mean filter 
        </h1>
        <h2>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        mean = cv2.blur(img, (5, 5))<br>
        plt.imshow(mean, cmap='gray')<br>
        plt.show()<br>
        </h2>
        <h1>
        homomorphic filter
        </h1>
        <h2>
        import cv2<br>
        import numpy as np<br>
        import matplotlib.pyplot as plt<br>


        img = np.float32(img)<br>
        img = img/255<br>

        rows,cols,dim=img.shape<br>

        rh, rl, cutoff = 2.5,0.5,32<br>

        imgYCrCb = cv2.cvtColor(img, cv2.COLOR_BGR2YCrCb)<br>
        y,cr,cb = cv2.split(imgYCrCb)<br>

        y_log = np.log(y+0.01)<br>

        y_fft = np.fft.fft2(y_log)<br>

        y_fft_shift = np.fft.fftshift(y_fft)<br>


        DX = cols/cutoff<br>
        G = np.ones((rows,cols))<br>
        for i in range(rows):<br>
            for j in range(cols):<br>
                G[i][j]=((rh-rl)*(1-np.exp(-((i-rows/2)**2+(j-cols/2)**2)/(2*DX**2))))+rl<br>

        result_filter = G * y_fft_shift<br>

        result_interm = np.real(np.fft.ifft2(np.fft.ifftshift(result_filter)))<br>

        result = np.exp(result_interm)<br>
        plt.imshow(result, cmap='gray')<br>
        plt.show()<br>

        </h2>

        <h1>
            rotation 

        </h1>
        <h2>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        rows, cols = img.shape<br>
        M = cv2.getRotationMatrix2D((cols/2, rows/2), 90, 1)<br>
        dst = cv2.warpAffine(img, M, (cols, rows))<br>
        plt.imshow(dst, cmap='gray')<br>
        plt.show()<br>

        </h2>
        <h1>
            translation
        </h1>
        <h2>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        rows, cols = img.shape<br>
        M = np.float32([[1, 0, 100], [0, 1, 50]])<br>
        dst = cv2.warpAffine(img, M, (cols, rows))<br>
        plt.imshow(dst, cmap='gray')<br>
        plt.show()<br>

        </h2>
        <h1>
            scaling
        </h1>
        <h2>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        res = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)<br>
        plt.imshow(res, cmap='gray')<br>
        plt.show()<br>
        </h2>
        <h1>
            shrinking
        </h1>
        <h2>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        res = cv2.resize(img, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_CUBIC)<br>
        plt.imshow(res, cmap='gray')<br>
        plt.show()<br>
        </h2>
        <h1>
            zooming
        </h1>
        <h2>
            
            import cv2<br>
            
            img=cv2.imread("C:/Users/vinee/Desktop/3 - 1/DIP/dip lab6/image1.jpg")<br>
            def zoom_at(img, zoom=1, angle=0, coord=None):<br>
                
                cy, cx = [ i/2 for i in img.shape[:-1] ] if coord is None else coord[::-1]<br>
                
                rot_mat = cv2.getRotationMatrix2D((cx,cy), angle, zoom)<br>
                result = cv2.warpAffine(img, rot_mat, img.shape[1::-1], flags=cv2.INTER_LINEAR)<br>
            
                return result<br>
            cv2.imshow('img',zoom_at(img, zoom=2, angle=0, coord=None))<br>
            cv2.waitKey(0)<br>
            cv2.destroyAllWindows()<br>
        </h2>
        <h1>
            using 3x3 mask for low pass filter
        </h1>
        <h2>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        kernel = np.ones((3,3),np.float32)<br>
        kernel 
        dst = cv2.filter2D(img,-1,kernel)<br>
        plt.imshow(dst, cmap='gray')<br>
        plt.show()<br>
        </h2>
        <h1>
            using 3x3 mask for high pass filter
        </h1>
        <h2>
            import cv2<br>
            import numpy as np<br>
            
            img=cv2.imread("C:/Users/aakar/OneDrive/Desktop/DIP 1/latest.jpg")<br>
            
            gaussian_img=cv2.GaussianBlur(img,(9,9),0)<br>
            gaussian_HPF=img-gaussian_img<br>
            x=np.concatenate((img, gaussian_HPF), axis=1)<br>

            
            cv2.imshow("gaussian high pass filter",x)<br>

            cv2.waitKey(0)<br>
            cv2.destroyAllWindows()<br>
        
        
        <h1>
            canny 
        </h1>

        <h2>


        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        edges = cv2.Canny(img,100,200)<br>
        plt.imshow(edges, cmap='gray')<br>
        plt.show()<br>
        </h2>
        <h1>
            robert filter
        </h1>
        <h2>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        robert_cross_v = np.array([[0,0, 0], [0, 1,0],[0,0,-1]])<br>
        robert_cross_h = np.array([[0,0, 0], [0, 0,1],[0,-1,0]])<br>
        vertical = ndimage.convolve(img, robert_cross_v)<br>
        horizontal = ndimage.convolve(img, robert_cross_h)<br>
        edged_img = np.sqrt(np.square(vertical) + np.square(horizontal))<br>    
        edged_img*=255<br>
        plt.imshow(edged_img, cmap='gray')<br>
        plt.show()<br>
        </h2>
        <h1>
            sobel filter
        </h1>

        <h2>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        img_b=cv2.GaussianBlur(img,(3,3),0)<br>
        sobelx = cv2.Sobel(img_b,cv2.CV_64F,1,0,ksize=5)<br>
        sobely = cv2.Sobel(img_b,cv2.CV_64F,0,1,ksize=5)<br>
        sobelxy=cv2.sobel(img_b,cv2.CV_64F,1,1,ksize=5)<br>
        plt.imshow(sobelx, cmap='gray')<br>
        plt.show()<br>
        plt.imshow(sobely, cmap='gray')<br>
        plt.show()<br>
        plt.imshow(sobelxy, cmap='gray')<br>
        plt.show()<br>
        </h2>
        <h1>
            laplacian filter
        </h1>
        <h2>

        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        img_b=cv2.GaussianBlur(img,(3,3),0)<br>
        laplacian = cv2.Laplacian(img_b,cv2.CV_64F)<br>
        plt.imshow(laplacian, cmap='gray')<br>
        plt.show()<br>
        </h2>
        <h1>
            prewitte filter
        </h1>
        <h2>

        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        img_b=cv2.GaussianBlur(img,(3,3),0)<br> 
        prewitt_x = np.array([[1,1, 1], [0, 0,0],[-1,-1,-1]])<br>
        prewitt_y = np.array([[-1,0, 1], [-1, 0,1],[-1,0,1]])<br>   
        img_prewitt_x = cv2.filter2D(img, -1, prewitt_x)<br>
        img_prewitt_y = cv2.filter2D(img, -1, prewitt_y)<br>
        plt.imshow(img_prewitt_x, cmap='gray')<br>
        plt.show()<br>
        plt.imshow(img_prewitt_y, cmap='gray')<br>
        plt.show()<br>

        </h2>
        <h1>
            hough transform
        </h1>
        <h2>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        edges = cv2.Canny(img,100,200)<br>
        lines = cv2.HoughLines(edges,1,np.pi/180,200)<br>
        for line in lines:<br>
            rho,theta = line[0]<br>
            a = np.cos(theta)<br>
            b = np.sin(theta)<br>
            x0 = a*rho<br>
            y0 = b*rho<br>
            x1 = int(x0 + 1000*(-b))<br>
            y1 = int(y0 + 1000*(a))<br>
            x2 = int(x0 - 1000*(-b))<br>
            y2 = int(y0 - 1000*(a))<br>
            cv2.line(img,(x1,y1),(x2,y2),(0,0,255),2)<br>
        plt.imshow(img, cmap='gray')<br>
        plt.show()<br>
        </h2>
        <h1>
            hough circle
        </h1>
        <h2>
        img = cv2.imread('image1.jpg')<br>
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>
        img = cv2.medianBlur(img,5)<br>
        cimg = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)<br>
        circles = cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,1,20,
                                    param1=50,param2=30,minRadius=0,maxRadius=0)<br>
        circles = np.uint16(np.around(circles))<br>
        for i in circles[0,:]:<br>
            # draw the outer circle<br>
            cv2.circle(cimg,(i[0],i[1]),i[2],(0,255,0),2)<br>
            # draw the center of the circle<br>
            cv2.circle(cimg,(i[0],i[1]),2,(0,0,255),3)<br>
        plt.imshow(cimg)<br>
        plt.show()<br>
        </h2>

        
        
    </div>


    
  </body>     
  </html>
